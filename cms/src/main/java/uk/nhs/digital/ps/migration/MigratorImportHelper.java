package uk.nhs.digital.ps.migration;

import static java.nio.file.Files.createDirectories;
import static org.apache.commons.io.FileUtils.deleteDirectory;

import org.apache.commons.io.FileUtils;
import org.slf4j.Logger;

import java.io.*;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;


/**
 * <p>
 *     This class is a counterpart to the Migrator application; supports server-side processing of
 *     the ZIP-ped import package generated by the latter, preparing it to be imported by the Groovy
 *     EXIM script.
 * </p><p>
 *   See {@linkplain #obtainMigrationPackage(String)} for more details.
 * </p><p>
 *     As certain methods of this class generate some temporary files on the disk, remember to call
 *     {@linkplain #cleanupTemporaryArtifacts()} once the import is completed.
 * </p>
 */
public final class MigratorImportHelper {

    private static final String JSON_FILES_ENCODING = "UTF-8";

    private final Logger log;

    public MigratorImportHelper(final Logger log) {
        this.log = log;
    }

    /**
     * @return Amount of disk space available on the file system used by this class to store temporary
     *         content; in human-friendly format.
     */
    public String getUsableSpace() {
        return FileUtils.byteCountToDisplaySize(getTempDir().toFile().getUsableSpace());
    }

    /**
     * <p>
     *     Main entry method which orchestrates the whole processing of the of the Migrator-generated import package,
     *     making it available for EXIM script to import: downloads the archive file, decompresses it and post-processes
     *     the unpacked content.
     * </p><p>
     *     The post-processing finds scans JSON EXIM files for paths to the attachment files and adjusts them to the
     *     actual locations of those files in the local filesystem.
     * </p><p>
     *     As this method generates some temporary files on the disk, remember to call
     *     {@linkplain #cleanupTemporaryArtifacts()} once the import is completed.
     * </p>
     *
     * @param url URL to obtain the Migrator-generated ZIP-ped import package from.
     *
     * @return Path to the un-compressed EXIM JSON files to import.
     */
    public String obtainMigrationPackage(final String url) {

        cleanupTemporaryArtifacts();

        // Expected ZIP file structure:
        // - exim/          - EXIM JSON import files
        // - attachments/   - attachment files

        final Path importPackageDir = getImportPackageDir();
        final Path archiveFile = getPath(importPackageDir, "import-package.zip");
        final Path contentDir = getPath(importPackageDir, "content");
        final Path eximFilesDir = getPath(contentDir, "exim");
        final Path attachmentsFilesDir = getPath(contentDir, "attachments");

        log.info("Obtaining import package");

        recreateDirs(importPackageDir, contentDir);

        downloadSingleFile(url, archiveFile);

        unzip(archiveFile, contentDir);

        postProcessEximJsonFiles(eximFilesDir, attachmentsFilesDir);

        log.info("Import package obtained and ready for import.");

        return eximFilesDir.toString();
    }

    /**
     * Removes all the temporary content generated by methods of this class.
     */
    public void cleanupTemporaryArtifacts() {
        try {
            log.info("Deleting {}", getImportPackageDir());

            deleteDirectory(getImportPackageDir().toFile());

            log.info("Done.");
        } catch (IOException exception) {
            throw new UncheckedIOException("Failed to remove " + getImportPackageDir(), exception);
        }
    }

    private static Path getImportPackageDir() {
        return getPath(getTempDir(), "import-package");
    }

    /**
     * Deletes (if exist) and recreates given directories (including their ancestor directories, if necessary).
     */
    private static void recreateDirs(final Path... directories) {
        Arrays.stream(directories).forEach(path -> {
            try {
                deleteDirectory(path.toFile());

                createDirectories(path);
            } catch (final IOException exception) {
                throw new RuntimeException("Failed to recreate directories.", exception);
            }
        });
    }

    private void downloadSingleFile(final String url, final Path downloadedFilePath) {
        log.info("Downloading from {} to {}", url, downloadedFilePath);

        try {
            FileUtils.copyURLToFile(new URL(url), downloadedFilePath.toFile());

            log.info("Done: file {} {}",
                downloadedFilePath,
                FileUtils.byteCountToDisplaySize(downloadedFilePath.toFile().length())
            );
        } catch (final IOException exception) {
            throw new UncheckedIOException("Failed to download from " + url, exception);
        }
    }

    private void unzip(final Path zipFilePath, final Path targetDirPath) {

        log.info("Unzipping {} into {}", zipFilePath, targetDirPath);
        try {
            try (final ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(zipFilePath.toFile()))) {

                long totalEntriesCount = new ZipFile(zipFilePath.toFile()).size();
                long unzippedEntriesCount = 0;

                for (ZipEntry zipEntry = zipInputStream.getNextEntry();
                     zipEntry != null;
                     zipEntry = zipInputStream.getNextEntry()) {

                    final Path newFile = Paths.get(targetDirPath.toString(), zipEntry.getName());

                    createDirectories(newFile.getParent());

                    try (final FileOutputStream fileOutputStream = new FileOutputStream(newFile.toFile())) {
                        final byte[] buffer = new byte[1024];
                        for (int len = zipInputStream.read(buffer); len > 0; len = zipInputStream.read(buffer)) {
                            fileOutputStream.write(buffer, 0, len);
                        }
                    }

                    zipInputStream.closeEntry();
                    unzippedEntriesCount++;

                    if (unzippedEntriesCount == totalEntriesCount || unzippedEntriesCount % 100 == 0) {
                        log.info("Files unzipped: {}/{}", unzippedEntriesCount, totalEntriesCount);
                    }
                }
            }

        } catch (final Exception exception) {
            throw new RuntimeException("Failed to unzip " + zipFilePath + " to " + targetDirPath, exception);
        }
    }

    private void postProcessEximJsonFiles(final Path eximJsonFilesDir,
                                          final Path importPackageAttachmentsDir
    ) {
        log.info("Updating attachment paths.");
        try {
            Files.walk(eximJsonFilesDir)
                .filter(path -> path.getFileName().toString().toLowerCase().endsWith(".json"))
                .forEach(path -> resolveAttachmentPathsPlaceholders(path, importPackageAttachmentsDir.toString()));
            log.info("Done.");
        } catch (final IOException exception) {
            throw new UncheckedIOException("Failed to update attachment paths", exception);
        }
    }

    private static Path getTempDir() {
        return Paths.get(System.getProperty("java.io.tmpdir"));
    }

    private static Path getPath(final Path parent, final String... item) {
        return Paths.get(parent.toString(), item);
    }

    /**
     * <p>
     *     EXIM appears to require absolute paths to the attachment files but those will differ between environments.
     * </p><p>
     *     This method find The IMPORT_PACKAGE_ATTACHMENTS_LOCATION placeholder prefixing attachment paths in EXIM JSON
     *     files and substitutes it with the actual local path of the directory containing the downloaded attachments.
     * </p>
     */
    private static void resolveAttachmentPathsPlaceholders(final Path eximJsonFile,
                                                           final String importPackageAttachmentsDir
    ) {
        final String placeholderRegex = "\\{IMPORT_PACKAGE_ATTACHMENTS_LOCATION\\}";

        try {
            final byte[] bytes = Files.readAllBytes(eximJsonFile);

            final String content = new String(bytes, JSON_FILES_ENCODING)
                .replaceAll(placeholderRegex, importPackageAttachmentsDir);

            FileUtils.write(eximJsonFile.toFile(), content, JSON_FILES_ENCODING);

        } catch (final IOException exception) {
            throw new UncheckedIOException("Failed to update attachment paths in " + eximJsonFile, exception);
        }
    }
}
